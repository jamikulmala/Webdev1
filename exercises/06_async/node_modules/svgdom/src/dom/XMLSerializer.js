function serialize (node, ...args) {
  switch (node.nodeType) {
  case node.ELEMENT_NODE:
    return serializeElement(node, ...args)
  case node.DOCUMENT_NODE:
  case node.COMMENT_NODE:
  case node.TEXT_NODE:
  case node.DOCUMENT_FRAGMENT_NODE:
  case node.DOCUMENT_TYPE_NODE:
  case node.PROCESSING_INSTRUCTION_NODE:
  case node.ATTRIBUTE_NODE:
    return ''
  default:
    throw new TypeError('Only Nodes and Attr objects can be serialized by this algorithm.')
  }
}

function serializeElement (node, contextNs, prefixMap, prefixIndex, wellFormed = true) {
  if (node.localName.includes(':')) throw new Error('The serialization of this node would not be a well-formed element.')

  const markup = '<'
  const qualifiedName = ''
  const skipEndTag = false
  const ignoreNamespaceDefinitionAttribute = false
  const map = new Map(...prefixMap)
  const localPrefixMap = new Map()

  // https://w3c.github.io/DOM-Parsing/#dfn-recording-the-namespace-information
}

export class XMLSerializer {
  // https://w3c.github.io/DOM-Parsing/#dfn-producing-an-xml-serialization-of-a-dom-node
  serializeToString (root /*: Node */) {
    const contextNs = null
    const prefixMap = new Map([ [ 'xml', 'http://www.w3.org/XML/1998/namespace' ] ])
    const prefixIndex = 1
    const wellFormed = true
    // try {
    return serialize(root, contextNs, prefixMap, prefixIndex, wellFormed)
    // } catch (e) {
    //  throw new Error('Invalid State Error')
    // }
  }
}
